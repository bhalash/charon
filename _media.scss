/**
 * Media Queries
 * -----------------------------------------------------------------------------
 * @category   Stylesheet
 * @package    Scss Helpers
 * @author     Mark Grealish <mark@bhalash.com>
 * @copyright  Copyright (c) 2015, Mark Grealish
 * @license    http://opensource.org/licenses/MIT The MIT License (MIT)
 * @version    1.0
 * @link       https://github.com/bhalash/scss-helpers
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Media Query Terms
 * -----------------------------------------------------------------------------
 */

$media-terms: (
    mod: ('only', 'not'),
    // Non-deprecated media query devices.
    media: ('all', 'print', 'screen', 'speech'),
    // Non-browser-prefixed @media features.
    property: (
        'height', 'width', 'device-width', 'device-height', 'aspect-ratio',
        'color', 'color-index', 'monochrome', 'resolution', 'scan', 'grid',
        'orientation'
    ),
    // Valid prefix mods.
    prefix: ('min', 'max'),
    // @media featured with a min/max prefix.
    prefixed: (
        'height', 'width', 'device-width', 'device-height', 'aspect-ratio',
        'color', 'color-index', 'monochrome', 'resolution'
    )
);

/**
 * Parse Number Range for Presets
 * -----------------------------------------------------------------------------
 * Stuff will break if you move this, ware ye. The map below relies upon this.
 *
 * @param   int     $min        Range minimum size.
 * @param   int     $max        Range maximum size.
 * @param   string  $property   Range property.
 * @return  string              Parsed media query range condition.
 */

@function size-range($min, $max, $property: 'device-width') {
   @return 'only screen and (min-#{$property}: #{$min}) and (max-#{$property}: #{$max})';
}

/**
 * Media Query Presets
 * -----------------------------------------------------------------------------
 */

$media-presets: (
    print: 'print',
    speech: 'speech',
    example: 'only screen and (max-width: 300px) and (min-height: 100vh)',
    watch: size-range(218px, 281px),
    smartphone: size-range(320px, 667px),
    tablet: size-range(600px, 1280px)
) !default;

/**
 * Test if Property is Prefixed
 * -----------------------------------------------------------------------------
 * @param   string      $property       Property to test for prefixedness.
 * @param   map         $map            Map of keywords.
 * @return  bool                        Property is prefixed, true/false.
 */

@function is-prefixed-property($property, $map: $media-terms) {
    @return index(map-get($map, prefixed), $property) != false;
}

/**
 * Test if Value is Valid Media Value
 * -----------------------------------------------------------------------------
 * TODO: Some media values are either boolean or have a keyword (like orientation)
 * instead of a number value.
 *
 * @param   string      $value          Candidate value.
 * @return  bool                        Candidate is valid media value, true/false.
 */

@function is-media-value($value) {
    @return type-of($value) == 'number';
}

/**
 * Parse Media Keyword
 * -----------------------------------------------------------------------------
 * Looping here is, like, triple the work of a single loop in parse-condition()
 * but the separation of function is worth it.
 *
 * TODO: Missing keywords, especially for prefixed query rules.
 *
 * @param   string      $keyword        Type of keyword to check.
 * @param   string      $query          Input media query.
 * @param   map         $map            Map of keywords.
 * @return  string      $parsed         Parsed keyword.
 */

@function parse-condition-term($keyword, $query, $map: $media-terms) {
    $parsed: null;

    @each $term in $query {
        @if $keyword == value and is-media-value($term) {
            $parsed: $term;    
        } @else if index(map-get($map, $keyword), $term) != null {
            // TODO: This logic needs to be complexified. Some media queries
            // (like monochrome) are boolean in nature.
            $parsed: $term;

            @if $keyword == prefix {
                // For min-foo or max-bar.
                $parsed: $parsed + '-';
            }

            // TODO: Further tests and conditions to go here.
        }
    }

    @if not $parsed {
        $parsed: '';
    }

    @return $parsed;
}

/**
 * Parse Media Query Condition
 * -----------------------------------------------------------------------------
 * @param   string      $query      Aggregate media query as it stands.
 * @param   map         $condition  Media query condition to be parsed.
 * @param   string      $switch     and/or switch for queries. and/, literally.
 * @return  string      $parsed     Parsed condition appended to query.
 */

@function parse-condition($query, $condition, $switch: 'and') {
    @if $query and $condition {
        $query: $query + ' #{$switch} ';
    } @else if not $query {
        // TODO: Better solution for this.
        $query: 'only screen and ';
    }

    // TODO: Add switch/check for 'only/all/not' and 'screen/speech,' etc.
    $prefix: parse-condition-term(prefix, $condition);
    $property: parse-condition-term(property, $condition);
    $value: parse-condition-term(value, $condition);

    $parsed: $query;
    $parsed: $parsed + '(';
    $parsed: $parsed + if(is-prefixed-property($property), $prefix, '');
    $parsed: $parsed + $property;
    $parsed: $parsed + if(is-prefixed-property($property), ': ' + $value, '');
    $parsed: $parsed + ')';

    @return $parsed;
}

/**
 * Media Query Mixin
 * -----------------------------------------------------------------------------
 * @param   list        $queries        Query conditions.
 */

@mixin media($queries...) {
    $query: null;

    @each $condition in $queries {
        @if map-has-key($media-presets, $condition) {
            $query: map-get($media-presets, $condition);
        } @else {
            @if $condition {
                // Query logic is AND for the purposes of this function.
                // TODO: Will work on AND/OR later.
                $query: parse-condition($query, $condition, 'and');
            }   
        }
    }

    @media #{$query} {
        @content;
    }
}

/**
 * Retina Pixel Density Screen
 * -----------------------------------------------------------------------------
 * TODO: Integrate into new solution.
 */

@mixin density($density) {
    @media
    screen and (-webkit-min-device-pixel-ratio: $density),
    screen and (min--moz-device-pixel-ratio: $density),
    screen and (-o-min-device-pixel-ratio: $density/1),
    screen and (min-device-pixel-ratio: $density),
    screen and (min-resolution: #{$density * 96} + dpi),
    screen and (min-resolution: #{$density} + dppx) {  
        @content;
    }
}

/**
 * Internet Explorer
 * -----------------------------------------------------------------------------
 * TODO: Integrate into new solution.
 *
 * I am happy to exclude Internet Explorer 11 because it is decently good. My
 * IE problems inecrease exponentially as I work backwards in time.
 * 
 * @link http://keithclark.co.uk/articles/moving-ie-specific-css-into-media-blocks/
 * @link http://keithclark.co.uk/articles/moving-ie-specific-css-into-media-blocks/media-tests/
 * @link http://www.limecanvas.com/css-hacks-targeting-ie-10/
 * @link http://www.paulirish.com/2009/browser-specific-css-hacks/
 * 
 * DO NOT USE THIS. 
 * 
 * Wait...what? It's a bad idea to mix conditional IE CSS and regular CSS. It's
 * here if you need it, but ask yourself first: should I really do this?
 */

@mixin ie($version: null) {
    @if $version {
        @if $version == 6 {
            $version: 'screen\9';
        } @else if $version == 7 {
            $version: '\0screen\,screen\9';
        } @else if $version == 8 {
            $version: '\0screen';
        } @else if $version == 9 {
            $version: 'screen\0';
        } @else if $version == 10 {
            $version: 'screen and (min-width:0\0)';
        }
    } @else {
        // Target 8, 9 and 10 by default.
        $version: 'screen\0';
    }

    @warn 'This is the terrible horrible no good very bad way to set IE fallback CSS!';
    @warn 'You are a very naughty developer';

    @media #{$version} {
        @content;
    }
}
