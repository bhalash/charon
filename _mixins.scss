/**
 * Useful Sass Mixins
 * -----------------------------------------------------------------------------
 * @category   Stylesheet
 * @package    Scss Helpers
 * @author     Mark Grealish <mark@bhalash.com>
 * @copyright  Copyright (c) 2015, Mark Grealish
 * @license    http://opensource.org/licenses/MIT The MIT License (MIT)
 * @version    2.0
 * @link       https://github.com/bhalash/scss-helpers
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Validate Unit
 * -----------------------------------------------------------------------------
 * Validate that a given length is a valid unit.
 * 
 * @param   string     $value    The candidate value. Can be number or keyword.
 * @return  bool                 Unit is valid true or false.
 * @link    http://hugogiraudel.com/2014/05/19/new-offsets-sass-mixin/
 */

@function valid-unit($value) {
  @return (type-of($value) == 'number' and not unitless($value)) or (index(auto initial inherit 0, $value) != false);
}

@function is-decimal($value) {
    @return (unitless($value) and $value != 0);
}

/**
 * Set Position of Fixed, Absolute or Relative Items
 * -----------------------------------------------------------------------------
 * I wanted a slightly different operation for my position mixin: To be able to 
 * use in a manner identical to margin or padding side shorthand:
 * 
 *      margin: 10px 20px 5px;
 *      @include absolute(10px 20px 5px);
 * 
 * This will generate: 
 * 
 *      position: absolute;
 *      top: 10px;
 *      left: 20px;
 *      right: 20px;
 *      bottom: 5px;
 *
 * If values are unitless and greater than zero, it will assume they decimal
 * values and generate rem dimensions.
 * 
 * @param   string      $position           Type of position (absolute, fixed, relative).
 * @param   map         $values             Values to be applied.
 * @param   map         $offsets            Sides for values (top, right, etc.).
 * @link http://hugogiraudel.com/2014/05/19/new-offsets-sass-mixin/
 * @link http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/
 */

@mixin position($position, $values, $offsets: null) {
    position: $position; 

    @if not $offsets {
        // 1. Default offsets list.
        $offsets: top right bottom left;

        @if length($values) == 1 {
            @for $i from 1 to 4 {
                // 1 or 4 values. If only one side input, duplicate it for the other sides.
                $values: append($values, nth($values, 1));
            }
        } @else if length($values) == 2 {
            // 2 values. Duplicate each value if two items provided.
            $offsets: top left bottom right;
            $values: append($values, nth($values, 1));
            $values: append($values, nth($values, 2));
        } @else if length($values) == 3 {
            // 3 values. Add extra side if three values provided.
            $offsets: top left bottom right;
            $values: append($values, nth($values, 2));
        }
    } @else {
        @if length($values) != length($offsets) {
            @warn 'The number of offset properties and offset values must be equal.';
        }
    }

    @each $offset in $offsets {
        $side: index($offsets, $offset);
        $value: nth($values, $side);

        @if not valid-unit($value) {
            @warn '"#{$side} is not a valid unit for this mixin.';
        } @else if is-decimal($value) {
            @include rem(#{$offset}, $value);
        } @else {
            #{$offset}: $value;
        }
    }
}

/**
 * Position Shorthand Mixins
 * -----------------------------------------------------------------------------
 * @param   map     $values         Values to be applied.
 * @param   map     $offsets        Sides for values (top, right, etc.).
 */

@mixin absolute($values, $offsets: null) {
    @include position(absolute, $values, $offsets);
}

@mixin fixed($values, $offsets: null) {
    @include position(fixed, $values, $offsets);
}

@mixin relative($values, $offsets: null) {
    @include position(relative, $values, $offsets);
}

/**
 * Fetch from Color Palette
 * -----------------------------------------------------------------------------
 * In short, the post advocates a mapped palette of colors and tones using a 
 * set schema, and then using this function to return the colors. 
 *
 *      $_color-base-gray: rgb(229,231,234);
 * 
 *      $palettes: (
 *          purple: (
 *              base: rgb(42,40,80),
 *              light: rgb(51,46,140),
 *              dark: rgb(40,38,65)
 *             ),
 *          gray: (
 *              base: $_color-base-gray,
 *              light: lighten($_color-base-gray, 10%),
 *              dark: darken($_color-base-gray, 10%)
 *          )
 *      );
 * 
 * @param   string      $color          Colour to be used from map.
 * @param   string      $tone           Default tone to be used.
 * @param   map         $palette        Palette of colours.
 * @return  string                      Colour chen from map.
 * @link http://erskinedesign.com/blog/friendlier-color-names-sass-maps/
 */

@function palette($color, $tone: 'base', $palette: $default-colors) {
    @return map-get(map-get($palette, $color), $tone);
}

/**
 * Fetch Named Asset
 * -----------------------------------------------------------------------------
 * $assets: (
 *      brand: (
 *          tuairisc: (
 *              black: $brands + 'tuairisc-black.svg',
 *              white: $brands + 'tuairisc-white.svg'
 *          ),
 *          foras: (
 *              black: 'foras-black.svg',
 *              white: 'foras-white.svg'
 *          ),
 *          greann: $brands + 'greann.svg'
 *      )
 *  );
 *
 * @param   string      $asset      Primary asset name.
 * @param   map         $secondary  Asset variant names.
 * @return  string      Returned image asset.
 * @link https://www.bhalash.com/archives/13544804892
 */

@function asset($asset, $variants: null) {
    $asset: map-get($assets, $asset);

    @if $variants {
        @each $variant in $variants {
            $asset: map-get($asset, $variant);
        }
    }

    @return url($asset);
}

/**
 * Prefix Attribute
 * -----------------------------------------------------------------------------
 * Automatically vendor prefixes to CSS properties. You should use autoprefixer! 
 * 
 * @param   string      $attribute       CSS attribute to be prefixed.
 * @param   string      $value           CSS value. 
 * @param   map         $prefixes        Map of prefixes to be applied.
 */

@mixin prefix($attribute, $value, $prefixes: webkit) {
    @each $prefix in $prefixes {
        #{'-' + $prefix + '-' + $attribute}: $value;
    }

    #{$attribute}: #{$value};
}

/**
 * Prefix Value
 * -----------------------------------------------------------------------------
 * Automatically vendor prefixes to CSS values. You should use autoprefixer! 
 * 
 * @param   string      $attribute       CSS attribute.
 * @param   string      $value           CSS value to be prefixed.
 * @param   map         $prefixes        Map of prefixes to be applied.
 */

@mixin prefix-value($attribute, $value, $prefixes: webkit) {
    @each $prefix in $prefixes {
        #{$attribute}: #{'-' + $prefix + '-' + $value};
    }

    #{$attribute}: #{$value};
}

/**
 * Social Images and Colours
 * -----------------------------------------------------------------------------
 * I wanted to reduce the work (and load time) of ubiqui-cancerous social 
 * icons. This mixin generates uses an SVG spritemap with PNG fallback to 
 * generate social icons for popular networks. Have a look at _defaults.scss to
 * see the list of currently supported services, as well as the format used. 
 * 
 * I have included black and white minimal icons; the background colours of the
 * element will be that for the relevant network.
 * 
 * @param   map     $size           Percentage width and height ratio for square-flex().
 * @param   map     $service        Service to be selectively output.
 * @param   map     $spritesheet    Map with information for spritesheet. 
 */

@mixin social-link($size: 100% 1, $service: null, $spritesheet: $spritesheet-white) {
    $sprites: map-get($spritesheet, sprites);
    $networks: map-get($spritesheet, networks);

    background-image: url(map-get($sprites, png));
    background-image: url(map-get($sprites, svg));

    // Icon size * number of rows in spritesheet.
    $w: nth($size, 1) * map-get($sprites, rows);
    // Icon size * number of columns in spritesheet.
    $h: nth($size, 1) * map-get($sprites, columns);

    background-size: $w $h;
    background-repeat: no-repeat;
    display: inline-block;
    @include square-flex($size);

    @if $service {
        // Only link given service, if provided.
        $bg: nth(map-get($networks, $service), 1);
        $x: nth(map-get($networks, $service), 2);
        $y: nth(map-get($networks, $service), 3);

        &.#{$service} {
            background-color: $bg;
            background-position: $x $y;
        }
    } @else {
        // Else iterate $networks to produce social links.
        @each $service, $network in $networks {
            $bg: nth($network, 1);
            $x: nth($network, 2);
            $y: nth($network, 3);

            &.#{$service} {
                background-color: $bg;
                background-position: $x $y; 
            }
        }
    }
}

/**
 * Section Interior Padding
 * -----------------------------------------------------------------------------
 * Responsive padding for sections without having to list it all by hand. 
 * $padding, $padding * 0.8, $padding * 0.6, etc...
 * 
 * @param   int     $padding            Initial padding value.
 * @param   map     $media              Map of responsive @media breakpoints.
 */

@mixin content-padding($padding, $media) {
    $padding-mod: 1; 

    padding-left: $padding;
    padding-right: $padding;

    @each $break in $media {
        @include media($break) {
            padding-left: $padding * $padding-mod;
            padding-right: $padding * $padding-mod;
        }

        $padding-mod: $padding-mod - 0.2;
    }

    @include media(smartphone) {
        padding-left: 0;
        padding-right: 0;
    }
}

/**
 * Flexbox Parent
 * -----------------------------------------------------------------------------
 * If you have come this far you should have an understanding of how, why and 
 * where you would use flexbox. These mixins generate unprefixed CSS flexbox
 * rules, with a fallback generated for IE8 for use through Flexie.
 * 
 * Two safe defaults are assumes for flex-direction and flex, but otherwise I 
 * leave browser defaults be.
 *
 * @param   string      $direction          Direction of flexbox. Column or row.
 * @param   string      $justify-content    Alignment of content along main axis.
 * @param   string      $wrap               Whether or not to wrap content.
 * @param   string      $align-items        Alignment of content along secondary axis.
 * @link https://css-tricks.com/snippets/css/a-guide-to-flexbox/
 * @link http://zomigi.com/blog/flexbox-syntax-for-ie-10/
 * @link http://flexiejs.com/
 */

@mixin flex-parent($direction: row, $justify: null, $wrap: null, $align: null) {
    display: flex;

    // No 2009 equivalent.
    flex-direction: $direction;

    @if $justify {
        justify-content: $justify;
    }

    @if $wrap {
        flex-wrap: $wrap;
    }

    @if $align {
        align-items: $align;
    }
}

/**
 * Flexbox Child
 * -----------------------------------------------------------------------------
 * @param   list      $flex         Default flex arguments.
 * @param   string    $align-self   Self-alignment position.
 * @param   int       $order        Order for self in flex parent.
 */

@mixin flex-child($flex: 1, $align: null, $order: null) {
    flex: $flex;

    @if $align {
        align-self: $align;
    }

    @if $order {
        order: $order;
    }
}

/**
 * Clearfix
 * -----------------------------------------------------------------------------
 * Bulletproof and Rock-Solid self-clearing float. You can tell it is both
 * Bulletproof and Rock-Solid since I capitalized the words. There are very rare
 * instances were I might need to use a clearing element (such as splitting
 * floating elements vertically).
 */

@mixin clearfix() {
    overflow: auto;

    &:after {
        clear: both;
        content: '';
        display: table;
    }
}

/**
 * Flexible Square Boxes
 * -----------------------------------------------------------------------------
 * Generate a box whose height is equal to the given ratio of the width.
 * Width can be of any size.
 * Ratio should be between 0 and foo.
 * 
 * @param   map     $size           Horizontal width and height ratio.
 * @link http://stackoverflow.com/a/13625843/1433400
 * @link http://alistapart.com/article/creating-intrinsic-ratios-for-video
 */

@mixin square-flex($size: 100% 1) {
    $width: nth($size, 1);
    $ratio: nth($size, 2);

    height: 0;
    padding-bottom: $width * $ratio;
    width: $width;
}
 
/**
 * Vertical Center
 * -----------------------------------------------------------------------------
 * @param   int     $amount         Amount of top and bottom padding.
 */

@mixin vertical-center($amount) {
    // Useful for vertically centering elements.
    padding-bottom: $amount;
    padding-top: $amount;
}

/**
 * Invert RGBA
 * -----------------------------------------------------------------------------
 * @param   int     $red            Red value. 
 * @param   int     $green          Green value.
 * @param   int     $blue           Blue value. 
 * @param   int     $alpha          Alpha value. 
 @ @return  map                     Inverted RGBA.
 */

@function rgba-opposite($red: 255, $green: 255, $blue: 255, $alpha: 0) {
    $red: 255 - $red;
    $green: 255 - $green;
    $blue: 255 - $blue;
    $alpha: 1 - $alpha;

    @return rgba($red, $green, $blue, $alpha);
}

/**
 * Split Paragraph into Columns
 * -----------------------------------------------------------------------------
 * @param   int     $count          Number of columns.
 * @param   int     $gap            Gap between columns.
 */

@mixin columns($count, $gap) {
    column-count: $count;
    column-gap: $gap;
}

/**
 * Placeholder Styles
 * -----------------------------------------------------------------------------
 * Generate styles for input placeholders in Internet Explorer, Firefox and 
 * Webkit browsers. Use as follows:
 * 
 *      input {
 *          @include placeholder-style() {
 *              foo: bar;
 *          }
 *      }
 */

@mixin placeholder-style() {
    &::-webkit-input-placeholder {
       @content;
    }

    &::-webkit-input-placeholder {
        @content;
    }

    &:-moz-placeholder {
        @content;
        opacity: 1;
    }

    &::-moz-placeholder {
        @content;
        opacity: 1;
    }

    &:-ms-input-placeholder {
        @content;
    }
}

/**
 * Background Coloured Mask
 * -----------------------------------------------------------------------------
 * Useful for when you have to layer text above a background image.
 */

%background-mask {
    position: relative;

    > * {
        /* Specific workaround for Mobile Safari: without this #interior content
         * will scroll behind the header. */
        -webkit-backface-visibility: hidden;
        // Child content must be raised owing to the background gradient.
        z-index: 2;
    }

    &:after {
        content: ' ';
        @include absolute(0);
    }
}

/**
 * Solid Background Mask
 * -----------------------------------------------------------------------------
 * @param   int     $red            Red value. 
 * @param   int     $green          Green value.
 * @param   int     $blue           Blue value. 
 * @param   int     $alpha          Alpha value. 
 */

@mixin solid-mask($red: 255, $green: 255, $blue: 255, $alpha: 1) {
    @extend %background-mask;

    &:after {
        background-color: rgba($red, $green, $blue, $alpha);
    }
}

/**
 * Gradient Background Mask
 * -----------------------------------------------------------------------------
 * @param   map     $start          Gradient start point.
 * @param   map     $end            Gradient end point.
 */

@mixin gradient-mask ($start: rgba(0,0,0,0.75), $end: rgba(0,0,0,0.25)) {
    @extend %background-mask;

    &:after {
        background: linear-gradient(to bottom, $start 0%, $end 100%);
    }
}

/**
 * @font-face Declaration
 * -----------------------------------------------------------------------------
 * There are a bunch of Sass/Scss @font-face mixins available on the Internet, 
 * but each of them is fundamentally inflexible. They variously:
 * 
 * 1. Require a fixed file path.
 * 2. Fixed existence of files, by which I mean each and every possible type of 
 *    file (eot, woff, etc).
 * 3. Fixed order of declaration.
 * 
 * With font-face, I hopefully have provided something a little bit more 
 * flexible: declare all of the attributes of your @font-face in a map, and then
 * call the font-face mixin.
 * 
 * Weight, stretch and style are all optional.
 *
 * Example map:
 *
 *      $open-sans: (
 *          family: 'font-name',
 *          folder: '/path/to/folder/',
 *          filename: 'FontName',
 *          types: ('ttf', 'woff', 'eot'),
 *          // Below attributes are optional.
 *          weight: 'normal',
 *          style: 'normal',
 *          stretch: 'condensed'
 *      );
 *
 * Then call with: 
 * 
 *      @include font-face($open-sans);
 *
 * @param   map         $font           Map of typeface information.
 */

@mixin font-face($font) { 
    $family: map-get($font, family);
    $folder: map-get($font, folder);
    $filename: map-get($font, filename);
    $types: map-get($font, types);
    $src: ();

    @font-face {
        font-family: $family;

        @each $type in $types {
            // Iterate to produce the path and type, and then set it.
            $path: $folder + $filename + '.' + $type; 
            $src: append($src, 'url(' + $path + ') format("' + $type + '"),');
        }

        src: #{$src};

        // Optionally override CSS text defaults:

        @if map-has-key($font, weight) {
            font-weight: map-get($font, weight);    
        }

        @if map-has-key($font, style) {
            font-style: map-get($font, style);
        }

        @if map-has-key($font, stretch) {
            // Not supported anywhere. Ware ye.
            font-stretch: map-get($font, stretch);
        }

        @content;
    } 
}
